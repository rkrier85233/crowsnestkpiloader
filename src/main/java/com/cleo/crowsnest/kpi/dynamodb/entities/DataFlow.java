package com.cleo.crowsnest.kpi.dynamodb.entities;

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGenerateStrategy;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedTimestamp;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBIgnore;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBRangeKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable;
import com.cleo.crowsnest.kpi.loader.entities.DataFlowDimension;
import com.cleo.crowsnest.kpi.loader.entities.DatastoreDimension;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;

@Getter
@Setter
@DynamoDBTable(tableName = "DataFlow")
public class DataFlow {
    @DynamoDBHashKey
    private String organizationId;
    @DynamoDBRangeKey
    private String id;
    private String name;
    private String lowerCaseName;
    private String description;
    private String operation;
    private Recurrence recurrence;
    private List<Source> sources;
    private List<Destination> destinations;
    private String creator;
    private Map<String, String> creatorAttributes;
    private Date created;
    @DynamoDBAutoGeneratedTimestamp(strategy = DynamoDBAutoGenerateStrategy.ALWAYS)
    private Date updated;

    // Public no arg constructor needed by persistence layer.
    public DataFlow() {
        this.sources = new ArrayList<>(1);
        this.destinations = new ArrayList<>(1);
    }

    // Keeping source as a collection because it will change in the future, but treating like a single reference for now.
    @DynamoDBIgnore
    public void setSource(Source source) {
        sources = new ArrayList<>();
        sources.add(source);
    }

    @DynamoDBIgnore
    public Source getSource() {
        return sources.isEmpty() ? null : sources.get(0);
    }

    // Keeping destination as a collection because it will change in the future, but treating like a single reference for now.
    @DynamoDBIgnore
    public void setDestination(Destination destination) {
        destinations = new ArrayList<>();
        destinations.add(destination);
    }

    @DynamoDBIgnore
    public Destination getDestination() {
        return destinations.isEmpty() ? null : destinations.get(0);
    }

    @Builder
    private DataFlow(@NonNull DataFlowDimension dataFlowDimension, @NonNull DatastoreDimension srcDs, @NonNull DatastoreDimension destDs, @NonNull Map<String, String> userAttributes, @NonNull Instant created) {
        this.id = dataFlowDimension.getId();
        this.name = dataFlowDimension.getName();
        this.lowerCaseName = name.toLowerCase();
        this.operation = dataFlowDimension.getOperation();
        this.recurrence = Recurrence.builder()
                .interval(dataFlowDimension.getInterval())
                .timeUnit(dataFlowDimension.getTimeUnit())
                .build();
        this.recurrence.setEnabled(dataFlowDimension.isScheduled());
        this.creator = userAttributes.get("sub");
        this.creatorAttributes = userAttributes;

        setSource(Source.builder()
                .datastore(srcDs)
                .userId(creator)
                .build());

        setDestination(Destination.builder()
                .datastore(destDs)
                .userId(creator)
                .build());

        this.organizationId = dataFlowDimension.getOrganizationId();
        this.created = Date.from(created);
    }

}
